import pandas as pd
from tabulate import tabulate
import re

def generate_final_prototype():
    """
    Generates the prototype by parsing tabulate's own header output
    to determine exact column widths for perfect alignment.
    """
    # 1. Hardcoded mock data
    call1 = "K1ABC"
    call2 = "W1XYZ"
    band_data = {
        "total_1": 15230, "unique_1": 5110, "common_1": 10120,
        "run_unique_1": 4100, "sp_unique_1": 900, "unk_unique_1": 110,
        "run_common_1": 6000, "sp_common_1": 4000, "unk_common_1": 120,
        "total_2": 14500, "unique_2": 4380, "common_2": 10120,
        "run_unique_2": 3800, "sp_unique_2": 500, "unk_unique_2": 80,
        "run_common_2": 6100, "sp_common_2": 3900, "unk_common_2": 120,
    }

    # 2. Prepare data and the sub-header for tabulate
    sub_headers = [
        "", "Total", "Unique", "Common",
        "Run", "S&P", "Unk", "Run", "S&P", "Unk"
    ]
    table_data = [
        [
            call1, band_data["total_1"], band_data["unique_1"], band_data["common_1"],
            band_data["run_unique_1"], band_data["sp_unique_1"], band_data["unk_unique_1"],
            band_data["run_common_1"], band_data["sp_common_1"], band_data["unk_common_1"]
        ],
        [
            call2, band_data["total_2"], band_data["unique_2"], band_data["common_2"],
            band_data["run_unique_2"], band_data["sp_unique_2"], band_data["unk_unique_2"],
            band_data["run_common_2"], band_data["sp_common_2"], band_data["unk_common_2"]
        ]
    ]

    # 3. Generate the full table using tabulate
    full_table_str = tabulate(
        table_data, headers=sub_headers, tablefmt="psql",
        stralign="left", numalign="right"
    )
    
    table_lines = full_table_str.split('\n')

    # 4. Extract exact cell contents (including padding) from the header line
    header_content_line = table_lines[1]
    header_cells = header_content_line.split('|')[1:-1] # Split and remove empty strings from ends
    
    # The full width of each column is the length of its header cell content
    widths = [len(cell) for cell in header_cells]

    if len(widths) < 10:
        print("Error: Could not parse 10 columns from tabulate output. Aborting.")
        return

    # 5. Manually construct the new top two lines with correct grouping
    unique_group_width = widths[4] + widths[5] + widths[6] + 2 # 3 cells + 2 '|' separators
    common_group_width = widths[7] + widths[8] + widths[9] + 2 # 3 cells + 2 '|' separators
    
    top_border = (
        f'+{"-" * widths[0]}+{"-" * widths[1]}+{"-" * widths[2]}+{"-" * widths[3]}+'
        f'{"-" * unique_group_width}+{"-" * common_group_width}+'
    )
    
    merged_header_line = (
        f'| {"":<{widths[0]-1}}| {"":<{widths[1]-1}}| {"":<{widths[2]-1}}| {"":<{widths[3]-1}}|'
        f'{"Unique QSOs":^{unique_group_width}}|'
        f'{"Common QSOs":^{common_group_width}}|'
    )

    # 6. Assemble and print the final, unified table
    print(f"--- 20M ---")
    print(top_border)
    print(merged_header_line)
    # Print the table generated by tabulate, but skipping its original top border
    print('\n'.join(table_lines[1:]))

if __name__ == "__main__":
    generate_final_prototype()